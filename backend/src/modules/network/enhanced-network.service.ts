import { Injectable, Logger } from "@nestjs/common"
import { NetworkService } from "./network.service"
import { WindowsPowerShellService } from "./agents/windows-powershell.service"
import { PythonAdvancedService } from "./agents/python-advanced.service"
import { NmapAgentService } from "./agents/nmap.service"
import { TracerouteAgentService } from "./agents/traceroute.service"
import { NetstatAgentService } from "./agents/netstat.service"
import type { Device, NmapScanConfig } from "./device.model"
import type { NetworkTopologyData } from "./network.types"
import { exec } from "child_process"
import { promisify } from "util"
import pLimit from 'p-limit';
import { ExecutionManagerService } from '../../execution-manager/execution-manager.service';

const execAsync = promisify(exec)

interface EnhancedScanConfig extends NmapScanConfig {
  useWindowsPowerShell?: boolean
  usePythonAdvanced?: boolean
  useNmapFallback?: boolean
  scanMethod?: "auto" | "powershell" | "python" | "nmap" | "hybrid"
  deepScan?: boolean
  stealth?: boolean
  threads?: number
}

interface EnhancedScanResult {
  success: boolean
  devices: Device[]
  topology: NetworkTopologyData
  scanMethod: string
  scanDuration: number
  statistics: {
    totalDevices: number
    activeDevices: number
    vulnerableDevices: number
    averageResponseTime: number
    osDistribution: { [key: string]: number }
    deviceTypes: { [key: string]: number }
    topPorts: { [key: string]: number }
  }
  error?: string
}

export interface EnhancedDevice extends Device {
  zabbixData?: {
    hostId?: string;
    hostName?: string;
    status?: 'enabled' | 'disabled';
    available?: number;
    metrics?: {
      cpu: number;
      memory: number;
      disk: number;
      network: number;
    };
  };
  unifiedHealth?: {
    score: number;
    status: 'healthy' | 'warning' | 'critical';
    lastUpdate: Date;
  };
}

@Injectable()
export class EnhancedNetworkService extends NetworkService {
  private readonly enhancedLogger = new Logger(EnhancedNetworkService.name)

  constructor(
    private readonly windowsPowerShell: WindowsPowerShellService,
    private readonly pythonAdvanced: PythonAdvancedService,
    nmapAgent: NmapAgentService,
    tracerouteAgent: TracerouteAgentService,
    netstatAgent: NetstatAgentService,
    executionManager: ExecutionManagerService,
  ) {
    super(nmapAgent, tracerouteAgent, netstatAgent, executionManager)
  }

  async executeEnhancedScan(config: EnhancedScanConfig, userId?: string): Promise<EnhancedScanResult> {
    const startTime = Date.now()

    try {
      this.enhancedLogger.log(`[ENHANCED] Démarrage scan amélioré: ${config.target}`)
      this.enhancedLogger.log(`[ENHANCED] Méthode: ${config.scanMethod || "auto"}`)

      // Détermination de la méthode de scan optimale
      const scanMethod = await this.determineBestScanMethod(config)
      this.enhancedLogger.log(`[ENHANCED] Méthode sélectionnée: ${scanMethod}`)

      let devices: Device[] = []
      let scanMethodUsed = scanMethod

      // Exécution du scan selon la méthode choisie
      switch (scanMethod) {
        case "powershell":
          devices = await this.executePowerShellScan(config)
          break

        case "python":
          devices = await this.executePythonScan(config)
          break

        case "hybrid":
          devices = await this.executeHybridScan(config)
          scanMethodUsed = "hybrid"
          break

        case "nmap":
        default:
          // Fallback vers le scan nmap original
          const originalResult = await this.scanNetwork(config.target, userId)
          devices = originalResult.devices
          scanMethodUsed = "nmap"
          break
      }

      // Enrichissement des données avec des informations supplémentaires
      const enrichedDevices = await this.enrichDevicesData(devices)

      // Supprimer la méthode generateNetworkTopology et tout appel associé
      // À la place, utiliser le TopologyService pour générer la topologie à partir des appareils enrichis

      // Calcul des statistiques
      const statistics = this.calculateStatistics(enrichedDevices)

      const scanDuration = Date.now() - startTime

      this.enhancedLogger.log(`[ENHANCED] Scan terminé en ${scanDuration}ms`)
      this.enhancedLogger.log(`[ENHANCED] ${enrichedDevices.length} appareils détectés`)

      return {
        success: true,
        devices: enrichedDevices,
        topology: {
          devices: [], // Topology will be generated by TopologyService
          connections: [],
          stats: {
            totalDevices: 0,
            activeDevices: 0,
            averageLatency: 0,
            averagePacketLoss: 0,
            totalBandwidth: { download: 0, upload: 0 },
          },
        },
        scanMethod: scanMethodUsed,
        scanDuration,
        statistics,
      }
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan amélioré: ${error.message}`)

      return {
        success: false,
        devices: [],
        topology: {
          devices: [],
          connections: [],
          stats: {
            totalDevices: 0,
            activeDevices: 0,
            averageLatency: 0,
            averagePacketLoss: 0,
            totalBandwidth: { download: 0, upload: 0 },
          },
        },
        scanMethod: "error",
        scanDuration: Date.now() - startTime,
        statistics: {
          totalDevices: 0,
          activeDevices: 0,
          vulnerableDevices: 0,
          averageResponseTime: 0,
          osDistribution: {},
          deviceTypes: {},
          topPorts: {},
        },
        error: error.message,
      }
    }
  }

  private async determineBestScanMethod(config: EnhancedScanConfig): Promise<string> {
    // Si une méthode spécifique est demandée
    if (config.scanMethod && config.scanMethod !== "auto") {
      return config.scanMethod
    }

    try {
      // Détection de l'environnement
      const isWindows = process.platform === "win32"
      const hasAdminRights = await this.checkAdminRights()
      const hasPython = await this.checkPythonAvailability()
      const hasPowerShell = await this.checkPowerShellAvailability()

      this.enhancedLogger.log(`[ENHANCED] Environnement détecté:`, {
        isWindows,
        hasAdminRights,
        hasPython,
        hasPowerShell,
      })

      // Logique de sélection intelligente
      if (isWindows && hasPowerShell && hasAdminRights) {
        // Windows avec PowerShell et droits admin = méthode optimale
        return "powershell"
      }

      if (hasPython && (config.deepScan || (config.threads && config.threads > 30))) {
        // Python pour les scans approfondis ou haute performance
        return "python"
      }

      if (isWindows && hasPowerShell && hasPython) {
        // Environnement complet = scan hybride
        return "hybrid"
      }

      // Fallback vers nmap
      return "nmap"
    } catch (error) {
      this.enhancedLogger.warn(`[ENHANCED] Erreur détection environnement: ${error.message}`)
      return "nmap"
    }
  }

  private async executePowerShellScan(config: EnhancedScanConfig): Promise<Device[]> {
    try {
      const psConfig = {
        networkRange: config.target,
        ports: this.getPortsFromConfig(config),
        deepScan: config.deepScan || false,
        stealth: config.stealth || false,
        threads: config.threads || 20,
      }

      const result = await this.windowsPowerShell.executePowerShellScan(psConfig)

      if (!result.success) {
        throw new Error(result.error || "Scan PowerShell échoué")
      }

      return result.devices.map((device) => this.windowsPowerShell.convertToDeviceModel(device))
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan PowerShell: ${error.message}`)
      throw error
    }
  }

  private async executePythonScan(config: EnhancedScanConfig): Promise<Device[]> {
    try {
      const pyConfig = {
        networkRange: config.target,
        ports: this.getPortsFromConfig(config),
        threads: config.threads || 50,
        timeout: config.stealth ? 2 : 1,
        enableNmap: true,
        enableScapy: false,
      }

      const result = await this.pythonAdvanced.executePythonScan(pyConfig)

      if (!result.success) {
        throw new Error(result.error || "Scan Python échoué")
      }

      return result.devices.map((device) => this.pythonAdvanced.convertToDeviceModel(device))
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan Python: ${error.message}`)
      throw error
    }
  }

  private async executeHybridScan(config: EnhancedScanConfig): Promise<Device[]> {
    try {
      this.enhancedLogger.log(`[ENHANCED] Démarrage scan hybride`)

      // Exécution des scans en parallèle
      const [psResult, pyResult] = await Promise.allSettled([
        this.executePowerShellScan(config).catch((error) => {
          this.enhancedLogger.warn(`[HYBRID] PowerShell échoué: ${error.message}`)
          return []
        }),
        this.executePythonScan(config).catch((error) => {
          this.enhancedLogger.warn(`[HYBRID] Python échoué: ${error.message}`)
          return []
        }),
      ])

      const psDevices = psResult.status === "fulfilled" ? psResult.value : []
      const pyDevices = pyResult.status === "fulfilled" ? pyResult.value : []

      this.enhancedLogger.log(`[HYBRID] PowerShell: ${psDevices.length} appareils`)
      this.enhancedLogger.log(`[HYBRID] Python: ${pyDevices.length} appareils`)

      // Fusion intelligente des résultats
      const mergedDevices = this.mergeDeviceResults(psDevices, pyDevices)

      this.enhancedLogger.log(`[HYBRID] Fusion: ${mergedDevices.length} appareils uniques`)

      return mergedDevices
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan hybride: ${error.message}`)
      throw error
    }
  }

  private mergeDeviceResults(psDevices: Device[], pyDevices: Device[]): Device[] {
    const deviceMap = new Map<string, Device>()

    // Ajout des appareils PowerShell (priorité haute pour Windows)
    psDevices.forEach((device) => {
      deviceMap.set(device.ipAddress, device)
    })

    // Fusion avec les appareils Python
    pyDevices.forEach((pyDevice) => {
      const existing = deviceMap.get(pyDevice.ipAddress)

      if (existing) {
        // Fusion des données (PowerShell prioritaire, Python complément)
        const merged: Device = {
          ...existing,
          // Garder le meilleur hostname
          hostname: existing.hostname || pyDevice.hostname,
          // Garder la meilleure détection MAC
          macAddress: existing.macAddress || pyDevice.macAddress,
          // Fusionner les ports ouverts
          stats: {
            ...existing.stats,
            services: [
              ...existing.stats.services,
              ...pyDevice.stats.services.filter((s) => !existing.stats.services.some((es) => es.port === s.port)),
            ],
          },
        }

        deviceMap.set(pyDevice.ipAddress, merged)
      } else {
        // Nouvel appareil détecté uniquement par Python
        deviceMap.set(pyDevice.ipAddress, pyDevice)
      }
    })

    return Array.from(deviceMap.values())
  }

  private async enrichDevicesData(devices: Device[]): Promise<Device[]> {
    const limit = pLimit(5); // Limite à 5 enrichissements en parallèle
    const start = Date.now();
    this.enhancedLogger.log(`[ENHANCED-ENRICH] Début enrichissement de ${devices.length} devices (max 5 en parallèle)`);
    const enrichedDevices = await Promise.all(
      devices.map(device => limit(async () => {
        try {
          // Ajout d'informations de sécurité
          const securityInfo = await this.analyzeDeviceSecurity(device)
          // Mise à jour des statistiques en temps réel
          const realtimeStats = await this.getRealtimeDeviceStats(device.ipAddress)
          return {
            ...device,
            stats: {
              ...device.stats,
              ...realtimeStats,
              // Ajout des informations de sécurité
              ...securityInfo,
            },
          }
        } catch (error) {
          this.enhancedLogger.warn(`[ENRICH] Erreur enrichissement ${device.ipAddress}: ${error.message}`)
          return device
        }
      }))
    );
    const duration = Date.now() - start;
    this.enhancedLogger.log(`[ENHANCED-ENRICH] Enrichissement terminé (${devices.length} devices) en ${duration} ms.`);
    return enrichedDevices;
  }

  private async analyzeDeviceSecurity(device: Device): Promise<any> {
    try {
      const vulnerabilities = []
      const securityScore = 100

      // Analyse des ports ouverts pour détecter les vulnérabilités
      const dangerousPorts = [21, 23, 135, 445, 1433, 3306, 5432]
      const openDangerousPorts = device.stats.services
        .filter((service) => dangerousPorts.includes(service.port))
        .map((service) => service.port)

      if (openDangerousPorts.length > 0) {
        vulnerabilities.push(`Ports dangereux ouverts: ${openDangerousPorts.join(", ")}`)
      }

      // Analyse spécifique Windows
      if (device.os.toLowerCase().includes("windows")) {
        const hasRDP = device.stats.services.some((s) => s.port === 3389)
        const hasSMB = device.stats.services.some((s) => s.port === 445)

        if (hasRDP) {
          vulnerabilities.push("RDP exposé (risque de brute force)")
        }

        if (hasSMB) {
          vulnerabilities.push("SMB exposé (risque EternalBlue)")
        }
      }

      return {
        securityScore: Math.max(0, securityScore - vulnerabilities.length * 20),
        vulnerabilities,
        lastSecurityScan: new Date(),
      }
    } catch (error) {
      this.enhancedLogger.error(`[SECURITY] Erreur analyse sécurité: ${error.message}`)
      return {
        securityScore: 0,
        vulnerabilities: ["Erreur analyse sécurité"],
        lastSecurityScan: new Date(),
      }
    }
  }

  private async getRealtimeDeviceStats(ipAddress: string): Promise<any> {
    try {
      // Test de latence en temps réel
      const latency = await this.measureLatency(ipAddress)

      // Test de bande passante basique
      const bandwidth = await this.testBandwidth(ipAddress)

      return {
        latency,
        bandwidth,
        lastStatsUpdate: new Date(),
      }
    } catch (error) {
      return {
        latency: 999,
        bandwidth: { download: 0, upload: 0 },
        lastStatsUpdate: new Date(),
      }
    }
  }

  private async checkAdminRights(): Promise<boolean> {
    try {
      if (process.platform === "win32") {
        const { stdout } = await execAsync("net session 2>nul")
        return stdout.length > 0
      }
      return process.getuid && process.getuid() === 0
    } catch {
      return false
    }
  }

  private async checkPythonAvailability(): Promise<boolean> {
    try {
      await execAsync("python --version")
      return true
    } catch {
      try {
        await execAsync("python3 --version")
        return true
      } catch {
        return false
      }
    }
  }

  private async checkPowerShellAvailability(): Promise<boolean> {
    try {
      await execAsync('powershell -Command "Get-Host"')
      return true
    } catch {
      return false
    }
  }

  /**
   * Calcule les statistiques globales à partir de la liste des devices enrichis
   */
  private calculateStatistics(devices: Device[]) {
    const totalDevices = devices.length;
    const activeDevices = devices.filter(d => d.stats.status === 'active').length;
    const vulnerableDevices = devices.filter(d => Array.isArray(d.stats.vulnerabilities) && d.stats.vulnerabilities.length > 0).length;
    const responseTimes = devices.map(d => d.stats.latency).filter(l => typeof l === 'number' && l > 0) as number[];
    const averageResponseTime = responseTimes.length > 0 ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 0;
    const osDistribution: { [key: string]: number } = {};
    const deviceTypes: { [key: string]: number } = {};
    const topPorts: { [key: string]: number } = {};

    for (const d of devices) {
      // OS
      const os = d.os || 'Unknown';
      osDistribution[os] = (osDistribution[os] || 0) + 1;
      // Type
      const type = d.deviceType || 'other';
      deviceTypes[type] = (deviceTypes[type] || 0) + 1;
      // Ports
      if (Array.isArray(d.stats.services)) {
        for (const s of d.stats.services) {
          const port = String(s.port);
          topPorts[port] = (topPorts[port] || 0) + 1;
        }
      }
    }
    return {
      totalDevices,
      activeDevices,
      vulnerableDevices,
      averageResponseTime,
      osDistribution,
      deviceTypes,
      topPorts,
    };
  }

  /**
   * Extrait la liste des ports à scanner à partir de la config (string ou tableau), sinon retourne undefined
   */
  private getPortsFromConfig(config: { ports?: string | number[]; deviceType?: string; }): number[] | undefined {
    if (Array.isArray(config.ports)) {
      return config.ports.map(Number).filter(p => !isNaN(p));
    }
    if (typeof config.ports === 'string' && config.ports.trim().length > 0) {
      return config.ports.split(',').map(p => parseInt(p.trim(), 10)).filter(p => !isNaN(p));
    }
    // Si un type d'appareil est précisé, utiliser la constante DEVICE_PORTS
    if (config.deviceType && typeof config.deviceType === 'string') {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const { DEVICE_PORTS, DeviceType } = require('./device.model');
      const typeKey = config.deviceType.toUpperCase();
      if (DeviceType[typeKey]) {
        return DEVICE_PORTS[DeviceType[typeKey]];
      }
    }
    return undefined;
  }
}
