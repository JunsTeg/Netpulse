import { Injectable, Logger } from "@nestjs/common"
import { NetworkService } from "./network.service"
import { WindowsPowerShellService } from "./agents/windows-powershell.service"
import { PythonAdvancedService } from "./agents/python-advanced.service"
import { NmapAgentService } from "./agents/nmap.service"
import { TracerouteAgentService } from "./agents/traceroute.service"
import { NetstatAgentService } from "./agents/netstat.service"
import type { Device, NmapScanConfig } from "./device.model"
import { DeviceType } from "./device.model"
import type { NetworkTopologyData } from "./network.types"
import { exec } from "child_process"
import { promisify } from "util"
import pLimit from 'p-limit';
import { ExecutionManagerService } from '../../execution-manager/execution-manager.service';

const execAsync = promisify(exec)

interface EnhancedScanConfig extends NmapScanConfig {
  useWindowsPowerShell?: boolean
  usePythonAdvanced?: boolean
  useNmapFallback?: boolean
  scanMethod?: "auto" | "powershell" | "python" | "nmap" | "hybrid"
  deepScan?: boolean
  stealth?: boolean
  threads?: number
  psTimeout?: number // Timeout pour PowerShell (ms)
  pyTimeout?: number // Timeout pour Python (ms)
}

interface EnhancedScanResult {
  success: boolean
  devices: Device[]
  topology: NetworkTopologyData
  scanMethod: string
  scanDuration: number
  statistics: {
    totalDevices: number
    activeDevices: number
    vulnerableDevices: number
    averageResponseTime: number
    osDistribution: { [key: string]: number }
    deviceTypes: { [key: string]: number }
    topPorts: { [key: string]: number }
  }
  error?: string
}

export interface EnhancedDevice extends Device {
  zabbixData?: {
    hostId?: string;
    hostName?: string;
    status?: 'enabled' | 'disabled';
    available?: number;
    metrics?: {
      cpu: number;
      memory: number;
      disk: number;
      network: number;
    };
  };
  unifiedHealth?: {
    score: number;
    status: 'healthy' | 'warning' | 'critical';
    lastUpdate: Date;
  };
}

@Injectable()
export class EnhancedNetworkService extends NetworkService {
  private readonly enhancedLogger = new Logger(EnhancedNetworkService.name)

  constructor(
    private readonly windowsPowerShell: WindowsPowerShellService,
    private readonly pythonAdvanced: PythonAdvancedService,
    nmapAgent: NmapAgentService,
    tracerouteAgent: TracerouteAgentService,
    netstatAgent: NetstatAgentService,
    executionManager: ExecutionManagerService,
  ) {
    super(nmapAgent, tracerouteAgent, netstatAgent, executionManager)
  }

  async executeEnhancedScan(config: EnhancedScanConfig, userId?: string): Promise<EnhancedScanResult> {
    const startTime = Date.now()

    try {
      this.enhancedLogger.log(`[ENHANCED] Démarrage scan amélioré: ${config.target}`)
      this.enhancedLogger.log(`[ENHANCED] Méthode: ${config.scanMethod || "auto"}`)

      // Détermination de la méthode de scan optimale
      const scanMethod = await this.determineBestScanMethod(config)
      this.enhancedLogger.log(`[ENHANCED] Méthode sélectionnée: ${scanMethod}`)

      let devices: Device[] = []
      let scanMethodUsed = scanMethod

      // Exécution du scan selon la méthode choisie
      switch (scanMethod) {
        case "powershell":
          devices = await this.executePowerShellScan(config)
          break

        case "python":
          devices = await this.executePythonScan(config)
          break

        case "hybrid":
          devices = await this.executeHybridScan(config)
          scanMethodUsed = "hybrid"
          break

        case "nmap":
        default:
          // Fallback vers le scan nmap original
          const originalResult = await this.scanNetwork(config.target, userId)
          devices = originalResult.devices
          scanMethodUsed = "nmap"
          break
      }

      // Enrichissement des données avec des informations supplémentaires
      const enrichedDevices = await this.enrichDevicesData(devices)

      // Supprimer la méthode generateNetworkTopology et tout appel associé
      // À la place, utiliser le TopologyService pour générer la topologie à partir des appareils enrichis

      // Calcul des statistiques
      const statistics = this.calculateStatistics(enrichedDevices)

      const scanDuration = Date.now() - startTime

      this.enhancedLogger.log(`[ENHANCED] Scan terminé en ${scanDuration}ms`)
      this.enhancedLogger.log(`[ENHANCED] ${enrichedDevices.length} appareils détectés`)

      return {
        success: true,
        devices: enrichedDevices,
        topology: {
          devices: [], // Topology will be generated by TopologyService
          connections: [],
          stats: {
            totalDevices: 0,
            activeDevices: 0,
            averageLatency: 0,
            averagePacketLoss: 0,
            totalBandwidth: { download: 0, upload: 0 },
          },
        },
        scanMethod: scanMethodUsed,
        scanDuration,
        statistics,
      }
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan amélioré: ${error.message}`)

      return {
        success: false,
        devices: [],
        topology: {
          devices: [],
          connections: [],
          stats: {
            totalDevices: 0,
            activeDevices: 0,
            averageLatency: 0,
            averagePacketLoss: 0,
            totalBandwidth: { download: 0, upload: 0 },
          },
        },
        scanMethod: "error",
        scanDuration: Date.now() - startTime,
        statistics: {
          totalDevices: 0,
          activeDevices: 0,
          vulnerableDevices: 0,
          averageResponseTime: 0,
          osDistribution: {},
          deviceTypes: {},
          topPorts: {},
        },
        error: error.message,
      }
    }
  }

  private async determineBestScanMethod(config: EnhancedScanConfig): Promise<string> {
    // Si une méthode spécifique est demandée
    if (config.scanMethod && config.scanMethod !== "auto") {
      return config.scanMethod
    }

    try {
      // Détection de l'environnement
      const isWindows = process.platform === "win32"
      const hasAdminRights = await this.checkAdminRights()
      const hasPython = await this.checkPythonAvailability()
      const hasPowerShell = await this.checkPowerShellAvailability()

      this.enhancedLogger.log(`[ENHANCED] Environnement détecté:`, {
        isWindows,
        hasAdminRights,
        hasPython,
        hasPowerShell,
      })

      // Logique de sélection intelligente optimisée pour le scan automatique
      if (isWindows && hasPowerShell && hasPython && hasAdminRights) {
        // Environnement Windows complet avec tous les outils = scan hybride optimal
        this.enhancedLogger.log(`[ENHANCED] Sélection: Scan hybride (PowerShell + Python)`)
        return "hybrid"
      }

      if (isWindows && hasPowerShell && hasAdminRights) {
        // Windows avec PowerShell et droits admin = très efficace
        this.enhancedLogger.log(`[ENHANCED] Sélection: PowerShell (droits admin)`)
        return "powershell"
      }

      if (hasPython && config.deepScan) {
        // Python pour les scans approfondis
        this.enhancedLogger.log(`[ENHANCED] Sélection: Python (mode approfondi)`)
        return "python"
      }

      if (hasPython && config.threads && config.threads > 50) {
        // Python pour les scans haute performance
        this.enhancedLogger.log(`[ENHANCED] Sélection: Python (haute performance)`)
        return "python"
      }

      if (isWindows && hasPowerShell) {
        // Windows avec PowerShell sans droits admin
        this.enhancedLogger.log(`[ENHANCED] Sélection: PowerShell (droits limités)`)
        return "powershell"
      }

      if (hasPython) {
        // Python disponible
        this.enhancedLogger.log(`[ENHANCED] Sélection: Python`)
        return "python"
      }

      // Fallback vers nmap
      this.enhancedLogger.log(`[ENHANCED] Sélection: Nmap (fallback)`)
      return "nmap"
    } catch (error) {
      this.enhancedLogger.warn(`[ENHANCED] Erreur détection environnement: ${error.message}`)
      return "nmap"
    }
  }

  private async executePowerShellScan(config: EnhancedScanConfig): Promise<Device[]> {
    try {
      const psConfig = {
        networkRange: config.target,
        ports: this.getPortsFromConfig(config),
        deepScan: config.deepScan || false,
        stealth: config.stealth || false,
        threads: config.threads || 20,
      }

      const result = await this.windowsPowerShell.executePowerShellScan(psConfig)

      if (!result.success) {
        throw new Error(result.error || "Scan PowerShell échoué")
      }

      return result.devices.map((device) => this.windowsPowerShell.convertToDeviceModel(device))
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan PowerShell: ${error.message}`)
      throw error
    }
  }

  private async executePythonScan(config: EnhancedScanConfig): Promise<Device[]> {
    try {
      const pyConfig = {
        networkRange: config.target,
        ports: this.getPortsFromConfig(config),
        threads: config.threads || 50,
        timeout: config.stealth ? 2 : 1,
        enableNmap: true,
        enableScapy: false,
      }

      const result = await this.pythonAdvanced.executePythonScan(pyConfig)

      if (!result.success) {
        throw new Error(result.error || "Scan Python échoué")
      }

      return result.devices.map((device) => this.pythonAdvanced.convertToDeviceModel(device))
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan Python: ${error.message}`)
      throw error
    }
  }

  private async executeHybridScan(config: EnhancedScanConfig): Promise<Device[]> {
    try {
      this.enhancedLogger.log(`[ENHANCED] Démarrage scan hybride optimisé`)

      // Configuration optimisée pour chaque méthode
      const psConfig = { ...config, threads: Math.floor((config.threads || 100) * 0.6) }
      const pyConfig = { ...config, threads: Math.floor((config.threads || 100) * 0.4) }

      // Timeouts configurables (30s par défaut)
      const psTimeout = config.psTimeout || 30000
      const pyTimeout = config.pyTimeout || 30000

      // Exécution des scans en parallèle avec timeouts individuels
      const hybridStart = Date.now()
      
      const [psResult, pyResult] = await Promise.allSettled([
        Promise.race([
          this.executePowerShellScan(psConfig),
          new Promise<Device[]>((_, reject) => 
            setTimeout(() => reject(new Error(`PowerShell timeout (${psTimeout}ms)`)), psTimeout)
          )
        ]).catch((error) => {
          this.enhancedLogger.warn(`[HYBRID] PowerShell échoué: ${error.message}`)
          return []
        }),
        Promise.race([
          this.executePythonScan(pyConfig),
          new Promise<Device[]>((_, reject) => 
            setTimeout(() => reject(new Error(`Python timeout (${pyTimeout}ms)`)), pyTimeout)
          )
        ]).catch((error) => {
          this.enhancedLogger.warn(`[HYBRID] Python échoué: ${error.message}`)
          return []
        }),
      ])

      const psDevices = psResult.status === "fulfilled" ? psResult.value : []
      const pyDevices = pyResult.status === "fulfilled" ? pyResult.value : []

      this.enhancedLogger.log(`[HYBRID] PowerShell: ${psDevices.length} appareils`)
      this.enhancedLogger.log(`[HYBRID] Python: ${pyDevices.length} appareils`)

      // Fusion intelligente des résultats avec priorité
      const mergedDevices = this.mergeDeviceResults(psDevices, pyDevices)
      const hybridDuration = Date.now() - hybridStart

      this.enhancedLogger.log(`[HYBRID] Fusion: ${mergedDevices.length} appareils uniques en ${hybridDuration}ms`)

      // Si aucun appareil trouvé, essayer le scan Nmap comme fallback
      if (mergedDevices.length === 0) {
        this.enhancedLogger.warn(`[HYBRID] Aucun appareil trouvé, fallback vers Nmap`)
        try {
          const nmapResult = await this.scanNetwork(config.target, "system-hybrid-fallback")
          if (nmapResult.success) {
            this.enhancedLogger.log(`[HYBRID] Fallback Nmap réussi: ${nmapResult.devices.length} appareils`)
            return nmapResult.devices
          } else {
            this.enhancedLogger.error(`[HYBRID] Fallback Nmap échoué: ${nmapResult.error}`)
            return []
          }
        } catch (fallbackError) {
          this.enhancedLogger.error(`[HYBRID] Erreur fallback Nmap: ${fallbackError.message}`)
          return []
        }
      }

      return mergedDevices
    } catch (error) {
      this.enhancedLogger.error(`[ENHANCED] Erreur scan hybride: ${error.message}`)
      // Fallback vers scan Nmap en cas d'erreur
      try {
        this.enhancedLogger.log(`[HYBRID] Fallback vers scan Nmap`)
        const nmapResult = await this.scanNetwork(config.target, "system-hybrid-error")
        return nmapResult.devices
      } catch (fallbackError) {
        this.enhancedLogger.error(`[HYBRID] Échec du fallback Nmap: ${fallbackError.message}`)
        throw error
      }
    }
  }

  private mergeDeviceResults(psDevices: Device[], pyDevices: Device[]): Device[] {
    const deviceMap = new Map<string, Device>()

    // Ajout des appareils PowerShell (priorité haute pour Windows)
    psDevices.forEach((device) => {
      deviceMap.set(device.ipAddress, device)
    })

    // Fusion intelligente avec les appareils Python
    pyDevices.forEach((pyDevice) => {
      const existing = deviceMap.get(pyDevice.ipAddress)

      if (existing) {
        // Fusion des données avec logique intelligente
        const merged: Device = {
          ...existing,
          // Priorité au hostname le plus informatif
          hostname: this.selectBestHostname(existing.hostname, pyDevice.hostname),
          // Priorité à la MAC la plus fiable
          macAddress: existing.macAddress || pyDevice.macAddress,
          // Fusionner les informations OS
          os: existing.os !== 'Unknown' ? existing.os : pyDevice.os,
          // Fusionner les types d'appareils
          deviceType: this.selectBestDeviceType(existing.deviceType, pyDevice.deviceType),
          // Fusionner les services de manière intelligente
          stats: {
            ...existing.stats,
            services: this.mergeServices(existing.stats.services, pyDevice.stats.services),
            // Garder les meilleures statistiques
            latency: Math.min(existing.stats.latency || Infinity, pyDevice.stats.latency || Infinity),
            bandwidth: this.mergeBandwidth(existing.stats.bandwidth, pyDevice.stats.bandwidth),
          },
        }

        deviceMap.set(pyDevice.ipAddress, merged)
      } else {
        // Nouvel appareil détecté uniquement par Python
        deviceMap.set(pyDevice.ipAddress, pyDevice)
      }
    })

    return Array.from(deviceMap.values())
  }

  private selectBestHostname(psHostname: string, pyHostname: string): string {
    if (!psHostname || psHostname === 'Unknown') return pyHostname
    if (!pyHostname || pyHostname === 'Unknown') return psHostname
    
    // Priorité au hostname le plus descriptif (plus long, contient des mots-clés)
    const psScore = this.calculateHostnameScore(psHostname)
    const pyScore = this.calculateHostnameScore(pyHostname)
    
    return psScore >= pyScore ? psHostname : pyHostname
  }

  private calculateHostnameScore(hostname: string): number {
    if (!hostname) return 0
    
    let score = hostname.length // Score de base basé sur la longueur
    
    // Bonus pour les mots-clés informatifs
    const keywords = ['server', 'router', 'switch', 'printer', 'nas', 'desktop', 'laptop', 'mobile']
    keywords.forEach(keyword => {
      if (hostname.toLowerCase().includes(keyword)) {
        score += 10
      }
    })
    
    // Malus pour les noms génériques
    if (hostname.match(/^[0-9.]+$/)) score -= 5 // IP uniquement
    if (hostname.toLowerCase().includes('unknown')) score -= 10
    
    return score
  }

  private selectBestDeviceType(psType: string, pyType: string): DeviceType {
    if (!psType || psType === 'Unknown') return this.mapStringToDeviceType(pyType)
    if (!pyType || pyType === 'Unknown') return this.mapStringToDeviceType(psType)
    
    // Priorité aux types plus spécifiques
    const specificTypes = ['Router', 'Switch', 'Printer', 'Server', 'NAS']
    const psSpecific = specificTypes.includes(psType)
    const pySpecific = specificTypes.includes(pyType)
    
    if (psSpecific && !pySpecific) return this.mapStringToDeviceType(psType)
    if (pySpecific && !psSpecific) return this.mapStringToDeviceType(pyType)
    
    return this.mapStringToDeviceType(psType) // Par défaut, garder PowerShell
  }

  private mapStringToDeviceType(typeString: string): DeviceType {
    if (!typeString) return DeviceType.OTHER
    
    const lowerType = typeString.toLowerCase()
    
    switch (lowerType) {
      case 'router':
        return DeviceType.ROUTER
      case 'switch':
        return DeviceType.SWITCH
      case 'ap':
      case 'access point':
      case 'accesspoint':
        return DeviceType.AP
      case 'server':
        return DeviceType.SERVER
      case 'desktop':
        return DeviceType.DESKTOP
      case 'laptop':
        return DeviceType.LAPTOP
      case 'mobile':
      case 'phone':
      case 'smartphone':
        return DeviceType.MOBILE
      case 'printer':
        return DeviceType.PRINTER
      default:
        return DeviceType.OTHER
    }
  }

  private mergeServices(psServices: any[], pyServices: any[]): any[] {
    const serviceMap = new Map<number, any>()
    
    // Validation et nettoyage des services PowerShell
    const validPsServices = Array.isArray(psServices) ? psServices.filter(s => s && typeof s === 'object' && s.port) : []
    
    // Validation et nettoyage des services Python
    const validPyServices = Array.isArray(pyServices) ? pyServices.filter(s => s && typeof s === 'object' && s.port) : []
    
    // Ajouter les services PowerShell
    validPsServices.forEach(service => {
      if (typeof service.port === 'number' && service.port > 0 && service.port <= 65535) {
        serviceMap.set(service.port, service)
      }
    })
    
    // Fusionner avec les services Python
    validPyServices.forEach(pyService => {
      if (typeof pyService.port === 'number' && pyService.port > 0 && pyService.port <= 65535) {
        const existing = serviceMap.get(pyService.port)
        if (!existing) {
          serviceMap.set(pyService.port, pyService)
        } else {
          // Fusionner les informations de service
          serviceMap.set(pyService.port, {
            ...existing,
            name: existing.name || pyService.name,
            version: existing.version || pyService.version,
            banner: existing.banner || pyService.banner,
            // Garder le meilleur statut
            status: existing.status === 'open' ? existing.status : pyService.status,
          })
        }
      }
    })
    
    return Array.from(serviceMap.values())
  }

  private mergeBandwidth(psBandwidth: any, pyBandwidth: any): any {
    if (!psBandwidth && !pyBandwidth) return undefined
    if (!psBandwidth) return pyBandwidth
    if (!pyBandwidth) return psBandwidth
    
    // Retourner la bande passante la plus élevée
    return {
      download: Math.max(psBandwidth.download || 0, pyBandwidth.download || 0),
      upload: Math.max(psBandwidth.upload || 0, pyBandwidth.upload || 0),
    }
  }

  private async enrichDevicesData(devices: Device[]): Promise<Device[]> {
    const limit = pLimit(5); // Limite à 5 enrichissements en parallèle
    const start = Date.now();
    this.enhancedLogger.log(`[ENHANCED-ENRICH] Début enrichissement de ${devices.length} devices (max 5 en parallèle)`);
    const enrichedDevices = await Promise.all(
      devices.map(device => limit(async () => {
        try {
          // Ajout d'informations de sécurité
          const securityInfo = await this.analyzeDeviceSecurity(device)
          // Mise à jour des statistiques en temps réel
          const realtimeStats = await this.getRealtimeDeviceStats(device.ipAddress)
          return {
            ...device,
            stats: {
              ...device.stats,
              ...realtimeStats,
              // Ajout des informations de sécurité
              ...securityInfo,
            },
          }
        } catch (error) {
          this.enhancedLogger.warn(`[ENRICH] Erreur enrichissement ${device.ipAddress}: ${error.message}`)
          return device
        }
      }))
    );
    const duration = Date.now() - start;
    this.enhancedLogger.log(`[ENHANCED-ENRICH] Enrichissement terminé (${devices.length} devices) en ${duration} ms.`);
    return enrichedDevices;
  }

  private async analyzeDeviceSecurity(device: Device): Promise<any> {
    try {
      const vulnerabilities = []
      const securityScore = 100

      // Analyse des ports ouverts pour détecter les vulnérabilités
      const dangerousPorts = [21, 23, 135, 445, 1433, 3306, 5432]
      const openDangerousPorts = device.stats.services
        .filter((service) => dangerousPorts.includes(service.port))
        .map((service) => service.port)

      if (openDangerousPorts.length > 0) {
        vulnerabilities.push(`Ports dangereux ouverts: ${openDangerousPorts.join(", ")}`)
      }

      // Analyse spécifique Windows
      if (device.os.toLowerCase().includes("windows")) {
        const hasRDP = device.stats.services.some((s) => s.port === 3389)
        const hasSMB = device.stats.services.some((s) => s.port === 445)

        if (hasRDP) {
          vulnerabilities.push("RDP exposé (risque de brute force)")
        }

        if (hasSMB) {
          vulnerabilities.push("SMB exposé (risque EternalBlue)")
        }
      }

      return {
        securityScore: Math.max(0, securityScore - vulnerabilities.length * 20),
        vulnerabilities,
        lastSecurityScan: new Date(),
      }
    } catch (error) {
      this.enhancedLogger.error(`[SECURITY] Erreur analyse sécurité: ${error.message}`)
      return {
        securityScore: 0,
        vulnerabilities: ["Erreur analyse sécurité"],
        lastSecurityScan: new Date(),
      }
    }
  }

  private async getRealtimeDeviceStats(ipAddress: string): Promise<any> {
    try {
      // Test de latence en temps réel
      const latency = await this.measureLatency(ipAddress)

      // Test de bande passante basique
      const bandwidth = await this.testBandwidth(ipAddress)

      return {
        latency,
        bandwidth,
        lastStatsUpdate: new Date(),
      }
    } catch (error) {
      return {
        latency: 999,
        bandwidth: { download: 0, upload: 0 },
        lastStatsUpdate: new Date(),
      }
    }
  }

  private async checkAdminRights(): Promise<boolean> {
    try {
      if (process.platform === "win32") {
        // Windows: vérifier les droits administrateur
        const { stdout } = await execAsync("net session 2>nul")
        return stdout.length > 0
      } else {
        // Unix/Linux: vérifier si l'utilisateur est root
        try {
          const uid = process.getuid()
          return uid === 0
        } catch (error) {
          // Si getuid() n'est pas disponible, essayer une autre méthode
          try {
            const { stdout } = await execAsync("id -u")
            return stdout.trim() === "0"
          } catch {
            return false
          }
        }
      }
    } catch (error) {
      this.enhancedLogger.debug(`[ENHANCED] Impossible de vérifier les droits admin: ${error.message}`)
      return false
    }
  }

  private async checkPythonAvailability(): Promise<boolean> {
    try {
      await execAsync("python --version")
      return true
    } catch {
      try {
        await execAsync("python3 --version")
        return true
      } catch {
        return false
      }
    }
  }

  private async checkPowerShellAvailability(): Promise<boolean> {
    try {
      await execAsync('powershell -Command "Get-Host"')
      return true
    } catch {
      return false
    }
  }

  /**
   * Calcule les statistiques globales à partir de la liste des devices enrichis
   */
  private calculateStatistics(devices: Device[]) {
    const totalDevices = devices.length;
    const activeDevices = devices.filter(d => d.stats.status === 'active').length;
    const vulnerableDevices = devices.filter(d => Array.isArray(d.stats.vulnerabilities) && d.stats.vulnerabilities.length > 0).length;
    const responseTimes = devices.map(d => d.stats.latency).filter(l => typeof l === 'number' && l > 0) as number[];
    const averageResponseTime = responseTimes.length > 0 ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 0;
    const osDistribution: { [key: string]: number } = {};
    const deviceTypes: { [key: string]: number } = {};
    const topPorts: { [key: string]: number } = {};

    for (const d of devices) {
      // OS
      const os = d.os || 'Unknown';
      osDistribution[os] = (osDistribution[os] || 0) + 1;
      // Type
      const type = d.deviceType || 'other';
      deviceTypes[type] = (deviceTypes[type] || 0) + 1;
      // Ports
      if (Array.isArray(d.stats.services)) {
        for (const s of d.stats.services) {
          const port = String(s.port);
          topPorts[port] = (topPorts[port] || 0) + 1;
        }
      }
    }
    return {
      totalDevices,
      activeDevices,
      vulnerableDevices,
      averageResponseTime,
      osDistribution,
      deviceTypes,
      topPorts,
    };
  }

  /**
   * Extrait la liste des ports à scanner à partir de la config (string ou tableau), sinon retourne undefined
   */
  private getPortsFromConfig(config: { ports?: string | number[]; deviceType?: string; }): number[] | undefined {
    if (Array.isArray(config.ports)) {
      return config.ports.map(Number).filter(p => !isNaN(p));
    }
    if (typeof config.ports === 'string' && config.ports.trim().length > 0) {
      return config.ports.split(',').map(p => parseInt(p.trim(), 10)).filter(p => !isNaN(p));
    }
    // Si un type d'appareil est précisé, utiliser la constante DEVICE_PORTS
    if (config.deviceType && typeof config.deviceType === 'string') {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const { DEVICE_PORTS, DeviceType } = require('./device.model');
      const typeKey = config.deviceType.toUpperCase();
      if (DeviceType[typeKey]) {
        return DEVICE_PORTS[DeviceType[typeKey]];
      }
    }
    return undefined;
  }
}
